"""
Plot estimation error of inferred signal in compressed sensing 
from error objects (.npz) generated by calculate_errors.py, 
averaged over 2nd variables. Allows to plot a batch of 
errors to compare.

Current plots generated with command line arguments:

mu_dSs_bkgrnd_seed_Kk2_med_diverse_Kk=7_Kk_split=1_WL  
mu_dSs_bkgrnd_seed_Kk2_med_diverse_Kk=7_Kk_split=1_no-WL  
mu_dSs_bkgrnd_seed_Kk2_med_diverse_Kk=7_Kk_split=4_WL  
mu_dSs_bkgrnd_seed_Kk2_med_diverse_Kk=7_Kk_split=4_no-WL 
mu_dSs_bkgrnd_seed_Kk2_med_diverse_Kk=7_Kk_split=6_WL  
mu_dSs_bkgrnd_seed_Kk2_med_diverse_Kk=7_Kk_split=6_no-WL

Created by Nirag Kadakia at 22:00 10-25-2017
This work is licensed under the 
Creative Commons Attribution-NonCommercial-ShareAlike 4.0 
International License. 
To view a copy of this license, visit 
http://creativecommons.org/licenses/by-nc-sa/4.0/.
"""


import scipy as sp
import sys
sys.path.append('../src')
import matplotlib.pyplot as plt
from matplotlib import cm
from mpl_toolkits.axes_grid1.inset_locator import mark_inset
from utils import get_flags, project_tensor, polygon_under_graph
from load_specs import read_specs_file
from save_load_data import save_signal_discrimination_weber_law_fig, \
							load_signal_discrimination_weber_law, \
							load_aggregated_object_list
from figure_plot_formats import signal_discrimination_weber_law_plot


def plot_signal_discrimination_weber_law(data_flags, axes_to_plot=[0, 1], 
				projected_variable_components=dict()):
	
	# Function to plot signal and inset; odor 2 is overlaid in darker color.
	def signal_plot(ax):
	
		ax.bar(sp.arange(Nn), CS_object_array[mu_dSs_to_plot, 
			seed_Kk2_to_plot[Kk_split_idx]].dSs*(-1)**Weber_idx, 
			lw=true_signal_lw, edgecolor=true_signal_color,
			zorder=100, width=1.0, fill=False)
		ax.bar(sp.arange(Nn), CS_object_array[mu_dSs_to_plot, 
			seed_Kk2_to_plot[Kk_split_idx]].dSs_est*(-1)**Weber_idx, 
			color=cmap(dual_odor_color_shades[0]), zorder=2, width=1.0)
		
		# Generate just odor 2 signal and plot over first plot
		signal_2 = sp.zeros(Nn)
		idxs_2 = CS_object_array[mu_dSs_to_plot, \
				seed_Kk2_to_plot[Kk_split_idx]].idxs_2
		for idx_2 in idxs_2:
			signal_2[idx_2] = CS_object_array[mu_dSs_to_plot, 
				seed_Kk2_to_plot[Kk_split_idx]].dSs_est[idx_2]
		ax.bar(sp.arange(Nn), signal_2*(-1)**Weber_idx, 
			color=cmap(dual_odor_color_shades[1]), zorder=3, width=1.0)
		
		return ax	
	
	# Define the plot indices
	Kk_split_idxs = len(data_flags)/2
	Weber_idxs = 2	
	assert len(data_flags) % 2 == 0, \
		"Need command line arguments to be Kk_split*2, alternating " \
		"Weber law and non-Weber law."
		
	# Ready the plotting window; colormaps; colors; signals to plot
	fig, ax = signal_discrimination_weber_law_plot(
				Kk_split_idxs=Kk_split_idxs)
	cmaps = [cm.Reds, cm.Blues]
	cmaps_r = [cm.Reds_r, cm.Blues_r]
	dual_odor_color_shades = [0.7, 0.3]
	success_plots_lw = 3.0
	true_signal_color = 'black'
	true_signal_lw = 0.8
	mu_dSs_to_plot = 27
	seed_Kk2_to_plot = [47, 66, 44]	
	
	# Plot
	for data_idx, data_flag in enumerate(data_flags):
		
		Weber_idx = data_idx % Weber_idxs
		Kk_split_idx = data_idx / Weber_idxs
		cmap = cmaps[Weber_idx]
		
		list_dict = read_specs_file(data_flag)
		iter_vars = list_dict['iter_vars']
		Nn = list_dict['params']['Nn']
		iter_plot_var = iter_vars.keys()[axes_to_plot[0]]
		x_axis_var = iter_vars.keys()[axes_to_plot[1]]
		
		data = load_signal_discrimination_weber_law(data_flag)
		successes = data['successes']
		successes_2 = data['successes_2']
		
		nAxes = len(successes.shape)
		if nAxes > 2:
			successes = project_tensor(successes, 
									iter_vars, projected_variable_components,
									axes_to_plot)
			successes_2 = project_tensor(successes_2, 
									iter_vars, projected_variable_components,
									axes_to_plot)
		# Switch axes if necessary
		if axes_to_plot[0] > axes_to_plot[1]:    
			successes = successes.T
			successes_2 = successes_2.T
				
		# Plot successes, averaged over second axis of successes array
		avg_successes = sp.average(successes, axis=1)*100.0
		avg_successes_2 = sp.average(successes_2, axis=1)*100.0
		ax['successes_%s' % Kk_split_idx].plot(iter_vars[iter_plot_var], 
					avg_successes, color=cmap(dual_odor_color_shades[0]), 
					zorder=2, lw=success_plots_lw)
		ax['successes_%s' % Kk_split_idx].plot(iter_vars[iter_plot_var], 
					avg_successes_2, color=cmap(dual_odor_color_shades[1]),
					zorder=1, lw=success_plots_lw)
		
		# Load CS objects for single stimuli plotting
		iter_vars_dims = []
		for iter_var in iter_vars:
			iter_vars_dims.append(len(iter_vars[iter_var]))		
		print ('Loading object list for single stimulus plot...'),
		CS_object_array = load_aggregated_object_list(iter_vars_dims, data_flag)
		print ('...loaded.')
						
		# Plot signal and inset
		ax['signal_%s' % Kk_split_idx] = \
			signal_plot(ax['signal_%s' % Kk_split_idx])
		ax['signal_insert_%s' % Kk_split_idx] = \
			signal_plot(ax['signal_insert_%s' % Kk_split_idx])
		if Weber_idx == 1:
			mark_inset(ax['signal_%s' % Kk_split_idx], 
				ax['signal_insert_%s' % Kk_split_idx], 
				loc1=3, loc2=4, fc="none", ec="0.5")
	
	
		save_signal_discrimination_weber_law_fig(fig)
	

if __name__ == '__main__':
	data_flags = get_flags()
	plot_signal_discrimination_weber_law(data_flags, axes_to_plot=[0, 1], 
				projected_variable_components=dict(normal_eps_tuning_width=15))