"""
Plot estimation error of inferred signal in compressed sensing 
from error objects (.npz) generated by calculate_errors.py, 
averaged over 2nd variables. Allows to plot a batch of 
errors to compare. Plots both the averaged success ratios (averaged 
over the different signals) and a sample signal estimation for each
one.

Created by Nirag Kadakia at 22:00 10-25-2017
This work is licensed under the 
Creative Commons Attribution-NonCommercial-ShareAlike 4.0 
International License. 
To view a copy of this license, visit 
http://creativecommons.org/licenses/by-nc-sa/4.0/.
"""


import scipy as sp
import sys
sys.path.append('../src')
import matplotlib.pyplot as plt
from matplotlib import cm
from mpl_toolkits.axes_grid1.inset_locator import mark_inset
from utils import get_flags, project_tensor
from load_specs import read_specs_file
from save_load_data import save_discrimination_accuracy_fig, \
							save_sample_estimation_fig, \
							load_signal_discrimination_weber_law, \
							load_aggregated_object_list
from figure_plot_formats import decoding_accuracy_subfigures


def plot_signal_discrimination_weber_law(data_flags, axes_to_plot=[0, 1], 
				projected_variable_components=dict()):
	
	
	# Define the plot indices
	Kk_split_idxs = len(data_flags)/2
	assert len(data_flags) % 2 == 0, \
		"Need command line arguments to be Kk_split*2, alternating " \
		"Weber law and non-Weber law."
		
	# Ready the plotting window; colormaps; colors; signals to plot
	cmaps = [cm.Reds, cm.Blues]
	dual_odor_color_shades = [0.7, 0.7]
			
	# Plot
	for Kk_split_idx in range(Kk_split_idxs):
		
		data_sets = ['successes', 'successes_2']
		
		for data_set_idx, data_set in enumerate(data_sets):
		
			fig = decoding_accuracy_subfigures()
			for Weber_idx in range(2):
				
				data_flag_idx = Weber_idx + Kk_split_idx*2
				data_flag = data_flags[data_flag_idx]
				
				# Blue for non-adapted; red for adapted
				cmap = cmaps[Weber_idx]
				
				list_dict = read_specs_file(data_flag)
				iter_vars = list_dict['iter_vars']
				Nn = list_dict['params']['Nn']
				iter_plot_var = iter_vars.keys()[axes_to_plot[0]]
				x_axis_var = iter_vars.keys()[axes_to_plot[1]]
				
				data = load_signal_discrimination_weber_law(data_flag)
				successes = data[data_set]
				
				nAxes = len(successes.shape)
				if nAxes > 2:
					successes = project_tensor(successes, iter_vars, 
												projected_variable_components,
												axes_to_plot)
												
				# Switch axes if necessary
				if axes_to_plot[0] > axes_to_plot[1]:    
					successes = successes.T
						
				# Plot successes, averaged over second axis of successes array
				avg_successes = sp.average(successes, axis=1)*100.0
				plt.plot(iter_vars[iter_plot_var], avg_successes, 
							color=cmap(dual_odor_color_shades[data_set_idx]),
							lw=5)
				
			# Save same plot in both Weber Law and non-Weber Law folders
			for Weber_idx in range(2):
				data_flag = data_flags[Weber_idx + Kk_split_idx*2]
				save_discrimination_accuracy_fig(fig, data_flag, data_set_idx)
			
		
if __name__ == '__main__':
	data_flags = get_flags()
	plot_signal_discrimination_weber_law(data_flags, axes_to_plot=[0, 1], 
				projected_variable_components=dict(normal_eps_tuning_width=15))